#!/usr/bin/env bash

set -e            # fail fast
set -o pipefail   # don't ignore exit codes when piping output
# set -x          # enable debugging

# Configure directories
build_dir=$1
cache_dir=$2
env_dir=$3

bp_dir=$(cd $(dirname $0); cd ..; pwd)

# Load some convenience functions like status(), echo(), and indent()
source $bp_dir/bin/common.sh

# Output npm debug info on error
trap cat_npm_debug_log ERR

# Look in package.json's engines.node field for a semver range
semver_range=$(cat $build_dir/package.json | $bp_dir/vendor/jq -r .engines.node)

# Resolve node version using semver.io
node_version=$(curl --silent --get --data-urlencode "range=${semver_range}" https://semver.io/node/resolve)

# Recommend using semver ranges in a safe manner
if [ "$semver_range" == "null" ]; then
  protip "Specify a node version in package.json"
  semver_range=""
elif [ "$semver_range" == "*" ]; then
  protip "Avoid using semver ranges like '*' in engines.node"
elif [ ${semver_range:0:1} == ">" ]; then
  protip "Avoid using semver ranges starting with '>' in engines.node"
fi

# Output info about requested range and resolved node version
if [ "$semver_range" == "" ]; then
  status "Defaulting to latest stable node: $node_version"
else
  status "Requested node range:  $semver_range"
  status "Resolved node version: $node_version"
fi

# Download node from Heroku's S3 mirror of nodejs.org/dist
status "Downloading and installing node"
node_url="http://s3pository.heroku.com/node/v$node_version/node-v$node_version-linux-x64.tar.gz"
curl $node_url -s -o - | tar xzf - -C $build_dir

# Move node (and npm) into ./vendor and make them executable
mkdir -p $build_dir/vendor
mv $build_dir/node-v$node_version-linux-x64 $build_dir/vendor/node
chmod +x $build_dir/vendor/node/bin/*
PATH=$PATH:$build_dir/vendor/node/bin

# Run subsequent node/npm commands from the build path
cd $build_dir

# If node_modules directory is checked into source control then
# rebuild any native deps. Otherwise, restore from the build cache.
if test -d $build_dir/node_modules; then
  status "Found existing node_modules directory; skipping cache"
  status "Rebuilding any native dependencies"
  npm rebuild 2>&1 | indent
elif test -d $cache_dir/node_modules; then
  status "Restoring node_modules directory from cache"
  cp -r $cache_dir/node_modules $build_dir/

  status "Pruning cached dependencies not specified in package.json"
  npm prune 2>&1 | indent
fi

# Scope config var availability only to `npm install`
(
  if [ -d "$env_dir" ]; then
    status "Exporting config vars to environment"
    export_env_dir $env_dir
  fi

  status "Installing dependencies"
  # Make npm output to STDOUT instead of its default STDERR
  npm install --userconfig $build_dir/.npmrc --production 2>&1 | indent
)

status "Caching node_modules directory for future builds"
rm -rf $cache_dir/node_modules
mkdir -p $cache_dir
test -d $build_dir/node_modules && cp -r $build_dir/node_modules $cache_dir/

status "Cleaning up node-gyp and npm artifacts"
rm -rf "$build_dir/.node-gyp"
rm -rf "$build_dir/.npm"

# If Procfile is absent, try to create one using `npm start`
if [ ! -e $build_dir/Procfile ]; then
  npm_start=$(cat $build_dir/package.json | $bp_dir/vendor/jq -r .scripts.start)

  # If `scripts.start` is set in package.json, or a server.js file
  # is present in the app root, then create a default Procfile
  if [ "$npm_start" != "null" ] || [ -f $build_dir/server.js ]; then
    status "No Procfile found; Adding npm start to new Procfile"
    echo "web: npm start" > $build_dir/Procfile
  else
    status "Procfile not found and npm start script is undefined"
    protip "Create a Procfile or specify a start script in package.json"
  fi
fi

# Update the PATH
status "Building runtime environment"
mkdir -p $build_dir/.profile.d
echo "export PATH=\"\$HOME/vendor/node/bin:\$HOME/bin:\$HOME/node_modules/.bin:\$PATH\";" > $build_dir/.profile.d/nodejs.sh

# Post package.json to nomnom service
# Use a subshell so failures won't break the build.
(
  curl \
    --data @$build_dir/package.json \
    --fail \
    --silent \
    --request POST \
    --header "content-type: application/json" \
    https://nomnom.heroku.com/?request_id=$REQUEST_ID \
    > /dev/null
) &

# Heroku Revision.
#
# Affixed to all vendored binary output to represent changes to the
# compilation environment without a change to the upstream version,
# e.g. PHP 5.3.27 without, and then subsequently with, libmcrypt.
heroku_rev='-2'

MCRYPT_VERSION="2.5.8"
PHP_VERSION="5.3.27"

MCRYPT_URL="https://heroku-buildpack-php.s3.amazonaws.com/mcrypt-""$MCRYPT_VERSION""$heroku_rev"".tar.gz"
echo "-----> Bundling mcrypt version $MCRYPT_VERSION"
curl --silent --max-time 60 --location "$MCRYPT_URL" | tar xz

PHP_URL="https://heroku-buildpack-php.s3.amazonaws.com/php-$PHP_VERSION""$heroku_rev"".tar.gz"
echo "-----> Bundling PHP version $PHP_VERSION"
curl --silent --max-time 60 --location "$PHP_URL" | tar xz

ln -s /app/php/bin/php bin/php

export BUILD_DIR=$1
export CACHE_DIR=$2

# Load common JVM functionality from https://github.com/heroku/heroku-buildpack-jvm-common
JVM_COMMON_BUILDPACK=https://heroku-jvm-common.s3.amazonaws.com/jvm-buildpack-common.tar.gz
curl --silent --location $JVM_COMMON_BUILDPACK | tar -x bin/java -zO > /tmp/jvm-common
source /tmp/jvm-common

# JDK version
if [ -z "$JAVA_VERSION" ]; then # could be set using user_env_compile
    if [ -f "${BUILD_DIR}/system.properties" ]; then
        JAVA_VERSION=$(get_app_system_value ${BUILD_DIR}/system.properties "java.runtime.version")
    else
        JAVA_VERSION=$DEFAULT_JDK_VERSION
    fi
fi

# Install JDK
if [ "$(is_supported_java_version ${JAVA_VERSION})" = "true" ]; then
    echo -n "-----> Installing OpenJDK ${JAVA_VERSION}..."
    install_java ${BUILD_DIR} ${JAVA_VERSION}
    jdk_overlay ${BUILD_DIR}
    echo "done"
else
    echo " !     Unsupported Java version: $JAVA_VERSION"
    exit 1
fi

# Make sure new JDK is visible to Leiningen
export PATH="$HOME/.jdk/bin:$PATH"

LEIN_VERSION="1.7.1"
LEIN_BIN_SOURCE="$(dirname $0)/../opt/lein1"
if [ "$LEIN_DEV" = "" ]; then
    export LEIN_NO_DEV=y
fi
RLWRAP=yes

# install leiningen jar
LEIN_JAR_URL="https://heroku-buildpack-clojure.s3.amazonaws.com/leiningen-$LEIN_VERSION-standalone.jar"
LEIN_JAR_CACHE_PATH="$CACHE_DIR/leiningen-$LEIN_VERSION-standalone.jar"
LEIN_JAR_SLUG_PATH="$BUILD_DIR/.lein/leiningen-$LEIN_VERSION-standalone.jar"

if [ ! -r "$LEIN_JAR_CACHE_PATH" ]; then
    echo "-----> Installing Leiningen"
    echo "       Downloading: leiningen-$LEIN_VERSION-standalone.jar"
    mkdir -p $(dirname $LEIN_JAR_CACHE_PATH)
    curl --silent --show-error --max-time 120 -L -o "$LEIN_JAR_CACHE_PATH" $LEIN_JAR_URL
else
    echo "-----> Using cached Leiningen $LEIN_VERSION"
fi

mkdir -p "$BUILD_DIR/.lein"
cp "$LEIN_JAR_CACHE_PATH" "$LEIN_JAR_SLUG_PATH"

# install rlwrap binary on lein 1.x
if [ "$RLWRAP" = "yes" ]; then
    RLWRAP_BIN_URL="https://s3.amazonaws.com/heroku-buildpack-clojure/rlwrap-0.3.7"
    RLWRAP_BIN_PATH=$BUILD_DIR"/.lein/bin/rlwrap"
    echo "       Downloading: rlwrap-0.3.7"
    mkdir -p $(dirname $RLWRAP_BIN_PATH)
    curl --silent --show-error --max-time 60 -L -o $RLWRAP_BIN_PATH $RLWRAP_BIN_URL
    chmod +x $RLWRAP_BIN_PATH
fi

# install lein script
LEIN_BIN_PATH=$BUILD_DIR"/.lein/bin/lein"
echo "       Writing: lein script"
mkdir -p $(dirname $LEIN_BIN_PATH)
cp $LEIN_BIN_SOURCE $LEIN_BIN_PATH
sed -i s/##LEIN_VERSION##/$LEIN_VERSION/ $LEIN_BIN_PATH

# create user-level profiles
LEIN_PROFILES_SOURCE="$(dirname $0)/../opt/profiles.clj"
cp -n $LEIN_PROFILES_SOURCE "$BUILD_DIR/.lein/profiles.clj"

# unpack existing cache
CACHE_STORE_DIR=$CACHE_DIR"/.m2"
CACHE_TARGET_DIR=$BUILD_DIR"/.m2"
rm -rf $CACHE_TARGET_DIR
if [ -d $CACHE_STORE_DIR ]; then
    cp -r $CACHE_STORE_DIR $CACHE_TARGET_DIR
else
    mkdir -p $CACHE_TARGET_DIR
fi

cd $BUILD_DIR
PATH=.lein/bin:$PATH JVM_OPTS="-Xmx600m" \
    LEIN_JVM_OPTS="-Xmx400m -Duser.home=$BUILD_DIR" \
    $BUILD_COMMAND 2>&1 | sed -u 's/^/       /'
if [ "${PIPESTATUS[*]}" != "0 0" ]; then
    echo " !     Failed to build."
    exit 1
fi

# populate profile.d
PROFILE_PATH="$BUILD_DIR/.profile.d/clojure.sh"
mkdir -p $(dirname $PROFILE_PATH)

echo "export JVM_OPTS=\"\${JVM_OPTS:--Xmx400m -Dfile.encoding=UTF-8}\"" >> $PROFILE_PATH
echo "export LEIN_NO_DEV=\"\${LEIN_NO_DEV:-yes}\"" >> $PROFILE_PATH
echo "export PATH=\"\$HOME/.jdk/bin:$PATH:\$HOME/.lein/bin\"" >> $PROFILE_PATH

# repack cache with new assets
rm -rf $CACHE_STORE_DIR
mkdir -p $(dirname $CACHE_STORE_DIR)
cp -r $CACHE_TARGET_DIR $CACHE_STORE_DIR

if [ "$LEIN_INCLUDE_IN_SLUG" = "no" ]; then
    rm "$LEIN_JAR_SLUG_PATH"
    rm -rf "$CACHE_TARGET_DIR"
fi

if [ "$LEIN_VERSION" = "1.7.1" ]; then
    rm -rf "$CACHE_TARGET_DIR"
fi
